<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>blog.keik.info</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="blog.keik.info">
<meta property="og:url" content="http://blog.keik.info/index.html">
<meta property="og:site_name" content="blog.keik.info">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="blog.keik.info">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="blog.keik.info" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro">
  <link rel="stylesheet" href="//fonts.googleapis.com/earlyaccess/notosansjapanese.css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">blog.keik.info</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.keik.info"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java-with-frontend" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/28/java-with-frontend/" class="article-date">
  <time datetime="2016-02-28T09:00:00.000Z" itemprop="datePublished">2016-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/28/java-with-frontend/">Java とフロントエンドの付き合い方、それとチュートリアル</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ウェブアプリにおける JavaScript と CSS の役割・規模・複雑度が年々ヤバいことになってきているのは今更言うまでもない。今や JavaScript は、モジュールごとに分割して TypeScript や次期仕様の ECMAscript といったいわゆる altJS で記述されたのち、変換 (Transpile)・結合 (Concatinate)・最小化 (Minify) されてリリースされる。</p>
<p>ウェブアプリ開発において今時 (?) の言語を使う職場やコミュニティでは、フロントエンド絡みのビルドはある程度定着していることだろう。それには、<a href="http://rubyonrails.org/" target="_blank" rel="external">Ruby on Rails</a> における <a href="https://github.com/rails/sprockets" target="_blank" rel="external">Sprockets</a> のような、フロントエンド開発をサポートする優れたライブラリの存在によって、手軽に方法論を取り入れることができたり、コミュニティ内に情報が流通する機会がもたらされていることにも関係があると思う。</p>
<h2 id="Java__u306E_u30D5_u30ED_u30F3_u30C8_u30A8_u30F3_u30C9_u4E8B_u60C5"><a href="#Java__u306E_u30D5_u30ED_u30F3_u30C8_u30A8_u30F3_u30C9_u4E8B_u60C5" class="headerlink" title="Java のフロントエンド事情"></a>Java のフロントエンド事情</h2><p>Java ウェブアプリ開発とフロントエンド開発を統合するためのツールや情報は少ない。</p>
<p>あくまで自分のケースだが、周囲で見かける Java ウェブアプリのフロントエンド開発は、依然旧世代的だ。JavaScript にビルドという考えがあることを知らない開発者も多い。そんな現場での典型的なフロントエンド開発の運用は次のような感じになる。</p>
<ul>
<li><code>&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;</code> から始まる <code>script</code> タグが10行以上並ぶ</li>
<li>common.js からはグローバルネームスペースにいくつもの変数・関数がエクスポートされる</li>
<li>common.js 以外に読み込んだページ固有スクリプトからもグローバルネームスペースへのエクスポートがある</li>
<li>一つの巨大な JavaScript や CSS ファイルができる</li>
</ul>
<p>こうした運用は、コードの見通しを悪化させ、グローバル依存のコードを増やし、テストが放棄される。その結果、バグを生んでメンテナビリティを失う。</p>
<p>もちろん Java に限ってのことではないのだが、情報が少なくてなんとも切ない状況にある言語であるのは事実だ。</p>
<h2 id="u30B7_u30F3_u30D7_u30EB_u306A_u30D5_u30ED_u30F3_u30C8_u30A8_u30F3_u30C9_u958B_u767A_u65B9_u6CD5_u304B_u3089_u306E_u7D71_u5408"><a href="#u30B7_u30F3_u30D7_u30EB_u306A_u30D5_u30ED_u30F3_u30C8_u30A8_u30F3_u30C9_u958B_u767A_u65B9_u6CD5_u304B_u3089_u306E_u7D71_u5408" class="headerlink" title="シンプルなフロントエンド開発方法からの統合"></a>シンプルなフロントエンド開発方法からの統合</h2><p>じゃあ、と意気込んでフロントエンド開発事情を調べてみれば、それはそれで混沌としていることが分かるだろう。npm、Bower、Grunt、gulp、Browserify、webpack、……。何かいろいろあって、うまく使うと驚くほど効率的な開発ができるようになるらしい。だが、まずはシンプルに始めたい。それなのにシンプルに始める方法を選ぶのが難しい。</p>
<p>ずばり、シンプルさを重視すれば、<a href="https://www.npmjs.com/" target="_blank" rel="external">npm</a> と <a href="http://browserify.org/" target="_blank" rel="external">Browserify</a> だけで始めるのがいい。</p>
<p>まずは Java ウェブアプリのフロントエンド開発に npm と Browserify を使用するところから始めよう。その後はツールを追加して効率性を高めていこう。そんな開発ワークフローを体験するためのチュートリアルを作った。とにかく一度、フロントエンドのモダンな開発ワークフローを体験してもらいたい。</p>
<h2 id="Java_+__u30D5_u30ED_u30F3_u30C8_u30A8_u30F3_u30C9_u958B_u767A_u7D71_u5408_u30C1_u30E5_u30FC_u30C8_u30EA_u30A2_u30EB"><a href="#Java_+__u30D5_u30ED_u30F3_u30C8_u30A8_u30F3_u30C9_u958B_u767A_u7D71_u5408_u30C1_u30E5_u30FC_u30C8_u30EA_u30A2_u30EB" class="headerlink" title="Java + フロントエンド開発統合チュートリアル"></a>Java + フロントエンド開発統合チュートリアル</h2><p>チュートリアルでは次のサンプル Todo アプリを使用する。</p>
<ul>
<li><a href="https://github.com/keik/spring-frontend-integration-example" target="_blank" rel="external">https://github.com/keik/spring-frontend-integration-example</a></li>
</ul>
<p>サンプルの動作・開発には次の環境が必要になる。</p>
<ul>
<li>JDK 8+</li>
<li>Apache Maven 3+</li>
<li>Node 4+</li>
<li>Gnu Make</li>
<li>Unix-like シェル環境 (Windows の場合 MSYS や Cygwin で可能)</li>
</ul>
<p>このチュートリアルは Node をインストールしたことがないレベルの初心者でも始められる。逆に説明が冗長だと感じたら飛ばしながら進むといい。</p>
<h3 id="0-__u6BB5_u53D6_u308A"><a href="#0-__u6BB5_u53D6_u308A" class="headerlink" title="0. 段取り"></a>0. 段取り</h3><p>チュートリアルは次の5つのステップに分かれており、サンプルアプリの各コミットに対応する。</p>
<ol>
<li>ベースとなるサーバアプリを用意する (<a href="https://github.com/keik/spring-frontend-integration-example/tree/ab4b918acb30ac49d8b2ee63e6d59432ce3d4e25" target="_blank" rel="external">ab4b918</a>)</li>
<li>フロントエンド開発用のファイルレイアウトとビルドタスクを作る (<a href="https://github.com/keik/spring-frontend-integration-example/tree/f985e88e0f925cb12bf013dd25e26b49c1cfd314" target="_blank" rel="external">f985e88</a>)</li>
<li>自動ビルドタスクを追加して効率化する (<a href="https://github.com/keik/spring-frontend-integration-example/tree/948cd78da0e418fc1d0e539275420942dd1db64b" target="_blank" rel="external">948cd78</a>)</li>
<li>自動ビルドを活用して JavaScript を実装する (<a href="https://github.com/keik/spring-frontend-integration-example/tree/132f9a5d932e9679732d06f8311ffe5ef5b5a372" target="_blank" rel="external">132f9a5</a>)</li>
<li>CSS の自動ビルドタスクを作り、CSS を実装する (<a href="https://github.com/keik/spring-frontend-integration-example/tree/1711f586b309d88e721f90b357ee1a0811719cf3" target="_blank" rel="external">1711f58</a>)</li>
</ol>
<h3 id="1-__u30D9_u30FC_u30B9_u3068_u306A_u308B_u30B5_u30FC_u30D0_u30A2_u30D7_u30EA_u3092_u7528_u610F_u3059_u308B"><a href="#1-__u30D9_u30FC_u30B9_u3068_u306A_u308B_u30B5_u30FC_u30D0_u30A2_u30D7_u30EA_u3092_u7528_u610F_u3059_u308B" class="headerlink" title="1. ベースとなるサーバアプリを用意する"></a>1. ベースとなるサーバアプリを用意する</h3><p><em>対応するコミット: <a href="https://github.com/keik/spring-frontend-integration-example/tree/ab4b918acb30ac49d8b2ee63e6d59432ce3d4e25" target="_blank" rel="external">ab4b918</a></em></p>
<p>Spring Boot を使った簡単な Todo アプリを用意した。なお、Spring Boot でサーバアプリを実装するところについてはチュートリアルの本目的ではないので省略する。この段階のファイルレイアウトは以下のようになっている。</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">└── todo-app                         ... for sources of a Spring Boot server app</span><br><span class="line"><span class="code">    ├── pom.xml</span></span><br><span class="line"><span class="code">    └── src</span></span><br><span class="line"><span class="code">        └── main</span></span><br><span class="line"><span class="code">            ├── java</span></span><br><span class="line"><span class="code">            └── resources</span></span><br><span class="line"><span class="code">                ├── application.yml</span></span><br><span class="line"><span class="code">                ├── static</span></span><br><span class="line"><span class="code">                └── templates</span></span><br></pre></td></tr></table></figure>
<p>Spring Boot は、組み込みサーバを起動してデプロイできる Maven ゴールが設定されている。次のコマンドで <a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a> にデプロイされる。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% mvn spring-boot:run</span><br></pre></td></tr></table></figure>
<p>まだ JavaScript は一切使用していない。以降の作業ではこれに JavaScript や CSS を加えてインタラクションと見栄えを整えていく。この段階での動作を確認しておくと以降のイメージがつかみやすいと思う。</p>
<h3 id="2-__u30D5_u30ED_u30F3_u30C8_u30A8_u30F3_u30C9_u958B_u767A_u7528_u306E_u30D5_u30A1_u30A4_u30EB_u30EC_u30A4_u30A2_u30A6_u30C8_u3068_u30D3_u30EB_u30C9_u30BF_u30B9_u30AF_u3092_u4F5C_u308B"><a href="#2-__u30D5_u30ED_u30F3_u30C8_u30A8_u30F3_u30C9_u958B_u767A_u7528_u306E_u30D5_u30A1_u30A4_u30EB_u30EC_u30A4_u30A2_u30A6_u30C8_u3068_u30D3_u30EB_u30C9_u30BF_u30B9_u30AF_u3092_u4F5C_u308B" class="headerlink" title="2. フロントエンド開発用のファイルレイアウトとビルドタスクを作る"></a>2. フロントエンド開発用のファイルレイアウトとビルドタスクを作る</h3><p><em>対応するコミット: <a href="https://github.com/keik/spring-frontend-integration-example/tree/f985e88e0f925cb12bf013dd25e26b49c1cfd314" target="_blank" rel="external">f985e88</a></em></p>
<p>このステップでは、以下のファイルレイアウトになることを目指して作業を進めていく。</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── todo-app                         ... for sources of a Spring Boot server app</span><br><span class="line">│  ├── pom.xml</span><br><span class="line">│  └── src</span><br><span class="line">│      └── main</span><br><span class="line">│          ├── java</span><br><span class="line">│          └── resources</span><br><span class="line">│              ├── application.yml</span><br><span class="line">│              ├── static</span><br><span class="line">│              │  └── bundle.js      ... built from todo-client/scripts/main.js</span><br><span class="line">│              └── templates</span><br><span class="line">└── todo-client                      ... for sources of client resources</span><br><span class="line"><span class="code">    ├── Makefile</span></span><br><span class="line"><span class="code">    ├── package.json</span></span><br><span class="line"><span class="code">    └── scripts                      ... for sources of a JavaScript to bundle</span></span><br><span class="line"><span class="code">        └── main.js                  ... entry point of JavaScript</span></span><br></pre></td></tr></table></figure>
<p>フロントエンド開発に使用するモジュールは、Node パッケージマネージャ npm を使用してインストールしていくのが基本になる。npm は Node に同梱されている。まずサーバアプリ開発用の todo-app ディレクトリと同じ階層に、フロントエンド開発用の todo-client ディレクトリを作成し、そこで npm を初期化しよう。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% mkdir todo-client</span><br><span class="line">% <span class="built_in">cd</span> todo-client</span><br><span class="line">% npm init</span><br></pre></td></tr></table></figure>
<p>すると対話形式でプロジェクト情報の入力を求められるが、さほど重要ではないし後で修正もできるため、適当に入力する。これが済むと package.json ファイルが作られる。このファイルは、Maven における pom.xml のような、npm にとっての依存パッケージ情報などを管理するためのものだ。</p>
<p>次にこのプロジェクトで必要な npm パッケージをインストールする。モジュールごとに分割した JavaScript をビルドするために使用するツール Browserify は次のコマンドでインストールできる。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% npm install browserify --save-dev</span><br></pre></td></tr></table></figure>
<p><code>--save-dev</code> オプションをつけると、今インストールしたパッケージ名とバージョンが package.json 内に追記される。類似するオプションとして <code>--save</code> というものもあり、package.json に追記されるフィールドが異なる。使い分け方としては、<code>--save-dev</code> は開発時にのみ必要なツール (Browserify など) を、<code>--save</code> はランタイムに必要なライブラリ (jQuery や Bootstrap など) を指定する。この package.json ファイルがある場所で <code>npm install</code> コマンドを実行すると、package.json にある依存パッケージが自動的にまとめてインストールされるので、他のマシン環境でもコマンドを実行するだけで同じ依存パッケージを簡単に揃えることができる。</p>
<p>npm でインストールしたパッケージは node_moduels ディレクトリ内に格納される。Browserify のような、コマンドラインツールを提供しているパッケージの場合、node_modules/.bin 以下に実行ファイルが配置されるので、次のように Browserify を起動してみよう。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% node_modules/.bin/browserify -h</span><br></pre></td></tr></table></figure>
<p>ヘルプが表示されるはずだ。さっそく JavaScript ファイルを作って Browserify で変換してみよう。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% mkdir scripts</span><br><span class="line">% <span class="built_in">echo</span> <span class="string">'console.log("hi")'</span> &gt; scripts/main.js</span><br><span class="line">% node_modules/.bin/browserify scripts/main.js</span><br></pre></td></tr></table></figure>
<p>標準出力に表示されたものが変換後の JavaScript だ。</p>
<p>今度は npm で jQuery をインストールし、これを読み込むコードを書いてみよう。それを変換し、サーバアプリの静的ファイル置き場に出力してみよう。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% npm install jquery --save</span><br><span class="line">% <span class="built_in">echo</span> <span class="string">'</span><br><span class="line">       var $ = require("jquery") // (1)</span><br><span class="line">       console.log($().jquery)   // (2)</span><br><span class="line">       '</span> &gt; scripts/main.js</span><br><span class="line">% mkdir ../todo-app/src/main/resources/static</span><br><span class="line">% node_modules/.bin/browserify scripts/main.js -o ../todo-app/src/main/resources/static/bundle.js</span><br></pre></td></tr></table></figure>
<p>こうしてビルドした bundle.js は、jQuery 本体のコード (1) と <code>console.log</code> で jQuery のバージョンを出力するコード (2) が結合された状態で出力される。これをサーバアプリの HTML テンプレート (todo-app/src/main/resources/templates/todos.html) で読み込むよう <code>script</code> タグを追加し、ページをリロードしてみよう。開発者ツールのコンソールに jQuery のバージョンが出力されるはずだ。</p>
<p>これが npm と Browserify による、最も基本的な JavaScript のビルド方法だ。</p>
<p>あとは楽をするために工夫をするフェーズだ。これまで <code>npm</code> や <code>mkdir</code> や <code>browserify</code> などのコマンドを、都度オプションを指定しながら直接実行してきた。これらのコマンド実行の流れを自動化する仕組みを Makefile で作っておくと便利だ。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">STATIC_DIR</span> = ../todo-app/src/main/resources/static</span><br><span class="line"></span><br><span class="line">all: clean $(STATIC_DIR)/bundle.js</span><br><span class="line"></span><br><span class="line">$(STATIC_DIR)/bundle.js: node_modules $(STATIC_DIR)</span><br><span class="line">	@node_modules/.bin/browserify scripts/main.js -o $@</span><br><span class="line"></span><br><span class="line">$(STATIC_DIR):</span><br><span class="line">	@mkdir -p $@</span><br><span class="line"></span><br><span class="line"><span class="title">clean:</span></span><br><span class="line">	@rm -rf <span class="variable">$(STATIC_DIR)</span></span><br><span class="line"></span><br><span class="line">node_modules: package.json</span><br><span class="line">	@npm install</span><br><span class="line"></span><br><span class="line"><span class="phony"><span class="keyword">.PHONY</span>: all clean</span></span><br></pre></td></tr></table></figure>
<p>開発に途中参加する開発者は、ソースコードと package.json がコミットされたリポジトリをクローンして <code>make</code> さえすれば、他のコマンドを逐一実行しなくても、ビルドが完了するようになる。</p>
<p>なお Make でなくとも、シェルスクリプトやバッチファイル、Java のエコシステムを使いたいというのなら Gradle や Ant でもいい。だが Maven ですべてを統合するというのはやめておこう。Maven との格闘が始まり、決して効率的にならないだろう。<a href="https://github.com/eirslett/frontend-maven-plugin" target="_blank" rel="external">frontend-maven-plugin</a> というのもあるが、タスクのカスタマイズが不自由になるのでオススメしない。</p>
<h3 id="3-__u81EA_u52D5_u30D3_u30EB_u30C9_u30BF_u30B9_u30AF_u3092_u8FFD_u52A0_u3057_u3066_u52B9_u7387_u5316_u3059_u308B"><a href="#3-__u81EA_u52D5_u30D3_u30EB_u30C9_u30BF_u30B9_u30AF_u3092_u8FFD_u52A0_u3057_u3066_u52B9_u7387_u5316_u3059_u308B" class="headerlink" title="3. 自動ビルドタスクを追加して効率化する"></a>3. 自動ビルドタスクを追加して効率化する</h3><p><em>対応するコミット: <a href="https://github.com/keik/spring-frontend-integration-example/tree/948cd78da0e418fc1d0e539275420942dd1db64b" target="_blank" rel="external">948cd78</a></em></p>
<p>Browserify によって JavaScript をビルドすることはできたが、JavaScript ファイルを編集するたびに <code>browserify</code> を手動で実行し再ビルドするのは面倒だ。そこで今度は、ビルド対象およびビルド対象が読み込んでいるファイルが変更されたら、自動的にビルドしてくれるツール <a href="https://github.com/substack/watchify" target="_blank" rel="external">watchify</a> を導入しよう。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% npm install watchify --save-dev</span><br></pre></td></tr></table></figure>
<p>watchify の使い方は Browserify とほぼ同じだ。基本的には自動ビルドするかしないかだけの違いしかない。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% node_modules/.bin/watchify scripts/main.js -o ../todo-app/src/main/resources/static/bundle.js -v -m</span><br></pre></td></tr></table></figure>
<p>追加した <code>-v</code> オプションは、再ビルドの実行結果が標準出力するためのもので、動作状況を確認するために付けておいたほうが便利だ。<code>-d</code> オプションは、変換後のファイルに Source Map をバンドルするためのもので、これによって Chrome デベロッパーツールなどで結合前のファイルが表示できるようになるためデバッグに便利だ。</p>
<p>上のコマンドを実行した状態で、main.js に適当な編集を加えてみよう。自動的に再ビルドされ bundle.js が更新されるはずだ。再ビルドは思ったより早く終わることだろう。Node のストリームのパフォーマンスの素晴らしさに感動しよう。</p>
<p>このコマンドのエイリアスも、Makefile に追加しておこう。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watch-js: node_modules $(STATIC_DIR)</span><br><span class="line">	@node_modules/.bin/watchify scripts/main.js -o <span class="variable">$(STATIC_DIR)</span>/bundle.js -v -m</span><br></pre></td></tr></table></figure>
<p>これで <code>make watch-js</code> を実行するだけで、インクリメンタルビルドが開始されるようになった。あとはガシガシ JavaScript を実装しよう。</p>
<h3 id="4-__u81EA_u52D5_u30D3_u30EB_u30C9_u3092_u6D3B_u7528_u3057_u3066_JavaScript__u3092_u5B9F_u88C5_u3059_u308B"><a href="#4-__u81EA_u52D5_u30D3_u30EB_u30C9_u3092_u6D3B_u7528_u3057_u3066_JavaScript__u3092_u5B9F_u88C5_u3059_u308B" class="headerlink" title="4. 自動ビルドを活用して JavaScript を実装する"></a>4. 自動ビルドを活用して JavaScript を実装する</h3><p><em>対応するコミット: <a href="https://github.com/keik/spring-frontend-integration-example/tree/132f9a5d932e9679732d06f8311ffe5ef5b5a372" target="_blank" rel="external">132f9a5</a></em></p>
<p>このステップでは、以下のファイルレイアウトになることを目指して作業を進めていく。</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── todo-app                         ... for sources of a Spring Boot server app</span><br><span class="line">│  ├── pom.xml</span><br><span class="line">│  └── src</span><br><span class="line">│      └── main</span><br><span class="line">│          ├── java</span><br><span class="line">│          └── resources</span><br><span class="line">│              ├── application.yml</span><br><span class="line">│              ├── static</span><br><span class="line">│              │  └── bundle.js      ... built from todo-client/scripts/main.js</span><br><span class="line">│              └── templates</span><br><span class="line">└── todo-client                      ... for sources of client resources</span><br><span class="line"><span class="code">    ├── Makefile</span></span><br><span class="line"><span class="code">    ├── package.json</span></span><br><span class="line"><span class="code">    └── scripts                      ... for sources of a JavaScript to bundle</span></span><br><span class="line"><span class="code">        ├── main.js                  ... entry point of JavaScript</span></span><br><span class="line"><span class="code">        └── page-specifics           ... for store page-specific scripts</span></span><br></pre></td></tr></table></figure>
<p>ステップ 3 で効率的にアプリを実装する準備ができたので、あとはひたすら実装する。Todo アプリの、Todo 追加・削除・完了を、AJax でサーバにリクエストするようにしよう。</p>
<p>このステップでのポイントは、ページ固有のスクリプトの実装・管理方法だ。</p>
<p>ページ固有スクリプトは、ページごとに分割して管理したい。最終的なリリースの仕方にはいくつかのパターンがあるが、今回はページ固有スクリプトも含めすべての JavaScript を一つのファイルにバンドルしてリリースすることにする。この場合、表示しているページ固有スクリプトだけが呼び出されるようにし、関係のないページ用スクリプトは呼び出されないようにする必要がある。これをうまくコントロールするためには、ページの <code>body</code> 要素の ID を参照するというアイデアが有効だ。</p>
<p>Todo 一覧ページ用の HTML テンプレート (todos.html) の <code>body</code> 要素には <code>page-todos</code> を付与しよう。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">id</span>=<span class="value">"page-todos"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>そして Todo 一覧ページ用スクリプトは scripts/page-specifics/todos.js に作成し、その中で <code>body</code> の ID を参照して処理を呼び出すかどうかを判断するようにしよう。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// todo-client/scripts/page-specifics/todos.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.body.id === <span class="string">'page-todos'</span>)</span><br><span class="line">  $(init)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// snips</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>これを main.js から読み込むようにする。Todo 一覧ページの他に新たなページが増えても、このように <code>body</code> の ID を参照させる方法で追加していけばいい。なお、ローカルのファイルを <code>require</code> する場合は、引数にファイルの相対パスを書き、<code>.js</code> は省略可能だ。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// todo-client/scripts/main.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./page-specifics/todos'</span>)</span><br></pre></td></tr></table></figure>
<p>JavaScript のビルド環境・開発ワークフローについてはひとまずこれで完成だ。Ajax による Todo 操作の実装についてはただの jQuery を使った実装なので、サンプルのソースコードを確認してほしい。</p>
<p>ところで今回のサンプルでは、ページ固有スクリプトしか作成しておらず、共通関数モジュールを定義していない。もし共通関数などをモジュール化する場合には、エクスポートしたい関数・オブジェクトなどを <code>module.exports</code> に代入するようにする。例えば、<code>greet</code> という関数を持つオブジェクトをエクスポートする場合は、次のように記述する。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  greet: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>このような <code>module.exports</code> に代入のあるファイルを <code>require</code> で読み込むと、戻り値として代入されたオブジェクトや関数が得られる。よって次のように読み込んで使うことができる。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line">utils.greet()</span><br></pre></td></tr></table></figure>
<p>上で作成したページ固有スクリプトのように、<code>module.exports</code> に代入していないファイルを読み込んだ場合は、ファイルの頭から処理が呼び出される動作になる。</p>
<p>この <code>module</code> 変数や <code>require</code> 関数によるモジュール管理は Node で使われている方式であり、CommonJS と呼ばれる。</p>
<h3 id="5-_CSS__u306E_u81EA_u52D5_u30D3_u30EB_u30C9_u30BF_u30B9_u30AF_u3092_u4F5C_u308A_u3001CSS__u3092_u5B9F_u88C5_u3059_u308B"><a href="#5-_CSS__u306E_u81EA_u52D5_u30D3_u30EB_u30C9_u30BF_u30B9_u30AF_u3092_u4F5C_u308A_u3001CSS__u3092_u5B9F_u88C5_u3059_u308B" class="headerlink" title="5. CSS の自動ビルドタスクを作り、CSS を実装する"></a>5. CSS の自動ビルドタスクを作り、CSS を実装する</h3><p><em>対応するコミット: <a href="https://github.com/keik/spring-frontend-integration-example/tree/1711f586b309d88e721f90b357ee1a0811719cf3" target="_blank" rel="external">1711f58</a></em></p>
<p>JavaScript と同じように、CSS の実装も効率化しよう。</p>
<p>このステップでは、以下のファイルレイアウトになることを目指して作業を進めていく。</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── todo-app                         ... for sources of a Spring Boot server app</span><br><span class="line">│  ├── pom.xml</span><br><span class="line">│  └── src</span><br><span class="line">│      └── main</span><br><span class="line">│          ├── java</span><br><span class="line">│          └── resources</span><br><span class="line">│              ├── application.yml</span><br><span class="line">│              ├── static</span><br><span class="line">│              │  ├── bundle.js      ... built from todo-client/scripts/main.js</span><br><span class="line">│              │  └── style.css      ... built from todo-client/styles/main.less</span><br><span class="line">│              └── templates</span><br><span class="line">└── todo-client                      ... for sources of client resources</span><br><span class="line"><span class="code">    ├── Makefile</span></span><br><span class="line"><span class="code">    ├── package.json</span></span><br><span class="line"><span class="code">    ├── scripts                      ... for sources of a JavaScript to bundle</span></span><br><span class="line"><span class="code">    │  ├── main.js                   ... entry point of JavaScript</span></span><br><span class="line"><span class="code">    │  └── page-specifics            ... for store page-specific scripts</span></span><br><span class="line"><span class="code">    └── styles                       ... for sources of a CSS to bundle</span></span><br><span class="line"><span class="code">        ├── main.less                ... entry point of CSS</span></span><br><span class="line"><span class="code">        └── page-specifics           ... for store page-specific styles</span></span><br></pre></td></tr></table></figure>
<p>まず CSS をより便利に記述するための <a href="http://less-ja.studiomohawk.com/" target="_blank" rel="external">Less</a> を導入する。公式ウェブサイトの紹介にあるように、Less は CSS 上で変数や演算、入れ子による記述を可能にしたようなものだ。Less は npm からインストール可能だ。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% npm install less --save-dev</span><br></pre></td></tr></table></figure>
<p>Less は <code>lessc</code> というコマンドラインツールを提供している。<code>lessc</code> に *.less ファイルを指定すると CSS が生成される。</p>
<p>そして Less のビルドも自動ビルド化したい。指定したファイルの変更を検知して、任意のコマンドを実行するパッケージ <a href="https://github.com/kimmobrunfeldt/chokidar-cli" target="_blank" rel="external">chokidar-cli</a> あるいは <a href="https://github.com/keik/watchf" target="_blank" rel="external">watchf</a> を導入しよう。chokidar-cli は有名だ。一方 watchf は変更されたファイル名をコマンドパートに埋め込むことができる。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% npm install watchf --save-dev</span><br></pre></td></tr></table></figure>
<p>Makefile に Less の手動ビルド・自動ビルドのタスクを追加しよう。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">STATIC_DIR</span> = ../todo-app/src/main/resources/static</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手動ビルド</span></span><br><span class="line">$(STATIC_DIR)/style.css: node_modules $(STATIC_DIR)</span><br><span class="line">	@node_modules/.bin/lessc styles/main.less $@</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自動ビルド</span></span><br><span class="line">watch-less: node_modules $(STATIC_DIR)</span><br><span class="line">	@node_modules/.bin/watchf <span class="string">"styles/**/*.less"</span> -c <span class="string">"node_modules/.bin/lessc styles/main.less $(STATIC_DIR)/style.css"</span></span><br></pre></td></tr></table></figure>
<p>これで <code>make watch-less</code> を実行すれば、Less が自動ビルドされるようになった。だが、<code>make watch-js</code> も同じような自動ビルドタスクだ。これを別の端末で起動させておくのは面倒だ。</p>
<p>よって、複数のタスクを並列実行する <code>watch</code> タスクも追加しよう。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">watch:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -j watch-js watch-less</span><br></pre></td></tr></table></figure>
<p>これで <code>make watch</code> すれば JavaScript も Less も自動ビルドされるようになる。他に並列実行したいプロセスが追加されたら、Makefile の <code>watch</code> ターゲットに追加していけばいい。</p>
<h2 id="99-__u4ED6_u306B_u4F55_u304C_u3067_u304D_u308B_u304B"><a href="#99-__u4ED6_u306B_u4F55_u304C_u3067_u304D_u308B_u304B" class="headerlink" title="99. 他に何ができるか"></a>99. 他に何ができるか</h2><p>Java アプリとビルドを統合する際は、todo-app および todo-client ディレクトリのある階層に、<code>mvn -f todo-app/pom.xml</code> と <code>make -C todo-client</code> を実行するタスクを持った親 Makefile を配置すればいい。</p>
<p>より効率的な開発のために、npm でインストールできる他のツールも活用していってほしい。カテゴリごとに便利なライブラリを紹介して終わりにしたい。</p>
<h3 id="u30DF_u30CB_u30D5_u30A1_u30A4"><a href="#u30DF_u30CB_u30D5_u30A1_u30A4" class="headerlink" title="ミニファイ"></a>ミニファイ</h3><p>リリースビルド時はミニファイをしたいので、JavaScript については <a href="https://github.com/mishoo/UglifyJS2" target="_blank" rel="external">UglifyJS2</a> を、CSS については <a href="https://github.com/less/less-plugin-clean-css" target="_blank" rel="external">less-plugin-clean-css
</a> を使うといい。</p>
<h3 id="u30B3_u30FC_u30C9_u5909_u63DB"><a href="#u30B3_u30FC_u30C9_u5909_u63DB" class="headerlink" title="コード変換"></a>コード変換</h3><p>JavaScript のソースに altJS などを使いたければ Browserify 時に追加の変換処理を加えるトランスフォーム (Browserify プラグイン) を使うといい。TypeScript や ECMAScript、CoffeeScript などから JavaScript に変換するものをはじめ、主要なトランスフォームは <a href="https://github.com/substack/node-browserify/wiki/list-of-transforms" target="_blank" rel="external">https://github.com/substack/node-browserify/wiki/list-of-transforms</a> にリストされている。</p>
<h3 id="u30B3_u30FC_u30C9_u30C1_u30A7_u30C3_u30AF"><a href="#u30B3_u30FC_u30C9_u30C1_u30A7_u30C3_u30AF" class="headerlink" title="コードチェック"></a>コードチェック</h3><p>Makefile にコードチェック (Lint) タスクを設定し、<code>all</code> ターゲットの依存に加えることで、コードチェックエラーがある場合にビルドを失敗させることができる。</p>
<p>コードチェックには <a href="http://eslint.org/" target="_blank" rel="external">ESLint</a> が機能性・使い勝手の両面からオススメだ。</p>
<h3 id="u30C6_u30B9_u30C8"><a href="#u30C6_u30B9_u30C8" class="headerlink" title="テスト"></a>テスト</h3><p>Makefile にテストタスクを設定し <code>all</code> ターゲットの依存に加えることで、テスト失敗時にビルドを失敗させることができる。</p>
<p>テストランナーは <a href="https://mochajs.org/" target="_blank" rel="external">mocha</a> や <a href="https://github.com/substack/tape" target="_blank" rel="external">tape</a> がシンプルでオススメだ。アサーションライブラリは <a href="https://github.com/power-assert-js/power-assert" target="_blank" rel="external">power-assert</a> が便利だが、セットアップに手こずるようなら <a href="http://chaijs.com/" target="_blank" rel="external">Chai</a> がシンプルだ。</p>
<h2 id="u6B21_u306E_u30B9_u30C6_u30C3_u30D7"><a href="#u6B21_u306E_u30B9_u30C6_u30C3_u30D7" class="headerlink" title="次のステップ"></a>次のステップ</h2><p>クライアント MVC フレームワークや仮想 DOM やサーバサイドレンダリングが待ち受けている。そう考えるとフロントエンドやっぱり結構難しい。ただ、このような技術がどんな場合にも求められるようになるのは当分先だと思うので、それまでのレベルの底上げとしてメンテナブルなフロントエンド開発を浸透させていきたい。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.keik.info/2016/02/28/java-with-frontend/" data-id="cil6d5z1d0005j5gzpp9ae1xm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/browserify/">browserify</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/less/">less</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/make/">make</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/">spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/task-runner/">task-runner</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-release-ac-box" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/22/release-ac-box/" class="article-date">
  <time datetime="2016-02-22T13:49:25.000Z" itemprop="datePublished">2016-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/22/release-ac-box/">オートコンプリートライブラリを作った話と UI 実装のテクニックについて</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>シンプルなオートコンプリートコンボボックス UI ライブラリ <a href="https://github.com/keik/ac-box" target="_blank" rel="external">ac-box</a> を作った。<a href="http://keik.info/ac-box/examples/" target="_blank" rel="external">デモはこちら</a>。</p>
<h2 id="u7279_u5FB4"><a href="#u7279_u5FB4" class="headerlink" title="特徴"></a>特徴</h2><ul>
<li>他の大きなライブラリに依存しない。スタンドアロン版ミニファイ済み 9KB。</li>
<li>UI の位置は自動で fix される。ボーダや背景などの装飾部分は独自に定義する。</li>
</ul>
<h2 id="u4F7F_u3044_u65B9"><a href="#u4F7F_u3044_u65B9" class="headerlink" title="使い方"></a>使い方</h2><p><a href="https://github.com/keik/ac-box#readme" target="_blank" rel="external">README</a> を参照してください。</p>
<h2 id="Typeahead__u3068_u304B_jQuery_UI__u3068_u304B_u3042_u308B_u3051_u3069_uFF1F"><a href="#Typeahead__u3068_u304B_jQuery_UI__u3068_u304B_u3042_u308B_u3051_u3069_uFF1F" class="headerlink" title="Typeahead とか jQuery UI とかあるけど？"></a>Typeahead とか jQuery UI とかあるけど？</h2><p>jQuery に依存したくない。</p>
<h2 id="u301C_u3059_u308B_u6A5F_u80FD_u306F_u306A_u3044_u306E_uFF1F"><a href="#u301C_u3059_u308B_u6A5F_u80FD_u306F_u306A_u3044_u306E_uFF1F" class="headerlink" title="〜する機能はないの？"></a>〜する機能はないの？</h2><p><a href="https://github.com/keik/ac-box/issues" target="_blank" rel="external">issue</a> にもらえれば対応できるかもしれないです。</p>
<h1 id="UI__u5B9F_u88C5_u306E_u30C6_u30AF_u30CB_u30C3_u30AF"><a href="#UI__u5B9F_u88C5_u306E_u30C6_u30AF_u30CB_u30C3_u30AF" class="headerlink" title="UI 実装のテクニック"></a>UI 実装のテクニック</h1><p>オートコンプリートは、シンプルな機能ながらも微妙に細かなインタラクションがあるため、UI 実装の練習になる。このライブラリでも使っている UI 実装のテクニックをいくつかメモした。興味のある方は参考にしてください。</p>
<h2 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h2><p><a href="http://facebook.github.io/flux/docs/overview.html#content" target="_blank" rel="external">Flux</a> アーキテクチャを実装している。<a href="https://github.com/keik/ac-box/blob/master/src/event-emitter.js" target="_blank" rel="external">ミニマムな Event Emitter はこんな感じ</a>。このライブラリだとストアの操作がほとんどないので、あまり意味はないけれど。</p>
<p>Flux アーキテクチャは、MVC アーキテクチャの一つの例でしかない。ところが、最近は MVC アーキテクチャの派生系が次々に登場してきて、もうこれ何が MVC だかわかんねえなっていう状況の中、Observer Pattern + Command Pattern による MVC アーキテクチャに単一データフローという制約を加えたもの改めて Flux という名前で再定義した。そうすることでたびたび発生していた MVC カオスに巻き込まれるのを回避して、初学者にも混乱なく分かりやすく使い始められるという印象を受ける。</p>
<h2 id="View__u30B9_u30C6_u30FC_u30C8_u3068_u30EC_u30F3_u30C0_u30E9_u30FC_u306B_u3088_u308B_u63CF_u753B"><a href="#View__u30B9_u30C6_u30FC_u30C8_u3068_u30EC_u30F3_u30C0_u30E9_u30FC_u306B_u3088_u308B_u63CF_u753B" class="headerlink" title="View ステートとレンダラーによる描画"></a>View ステートとレンダラーによる描画</h2><p>UI の状態制御には、次のような、View ステートとレンダラーを使った実装方法がある。</p>
<ol>
<li><p>イベントハンドラ内で、次のような View ステートのプロパティを更新する</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">  <span class="comment">// オートコンプリートメニュー開閉状態。input にフォーカスあたったら true にしたりする</span></span><br><span class="line">  isOpen: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// input に設定する値。ESC でメニュー選択を中断したりしたいので、DOM 要素のプロパティ外にステートとして保持する</span></span><br><span class="line">  value: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// オートコンプリートメニュー内でフォーカスがあたっている場所を表す数字。UP とか DOWN でインクリ / デクリメントする</span></span><br><span class="line">  focusedIndex: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>その後レンダリング関数をコール。レンダリング関数は View ステートを参照して DOM 要素を更新する</p>
</li>
</ol>
<p>この方式の場合、レンダリング関数が割とクソ実装な見栄えになってしまうことがある。それでも、そこそこ複雑なインタラクションのある UI を制御するにはこの方法がいい。</p>
<p>対比として、イベントハンドラ内で直接 DOM 要素を更新する実装を考えた場合、連続的に発生するイベントに対して表示状態の一貫性が保てずに破綻しがちになる。例えば、<code>click</code> イベントでメニューを選択するというイベントハンドラを実装する際、気持ちの上では <code>click</code> のみ Listen したい。だが実際には <code>mousedown</code> や <code>mouseup</code> や <code>blur</code> や <code>focus</code> などのイベントが連続的に発生する。これらのイベントハンドラと整合させつつ描画を更新する場合に View ステートというクッションを挟むことで、制御がしやすくなる。オプションで動作にバリエーションをもたせるような場合にも拡張しやすい。</p>
<p>そして View ステートから DOM 要素の更新を最小パッチで自動的に行うのが、我らがイケメン <a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a> なのでライブラリではなくアプリを作るなら React 使うといいと思う。他に <a href="https://github.com/Reactive-Extensions/RxJS" target="_blank" rel="external">RxJS</a> も気になるが、まだ使ったことがない。</p>
<h2 id="u753B_u50CF_u3092_u4F7F_u308F_u306A_u3044"><a href="#u753B_u50CF_u3092_u4F7F_u308F_u306A_u3044" class="headerlink" title="画像を使わない"></a>画像を使わない</h2><p>メニュー展開状態を示すキャレットアイコンなどは CSS の <code>border</code> プロパティで作り、画像は使っていない。外部アセットファイルを増やしたくないから。Bootstrap のキャレットもこうやって作られているし、割と定番なテクニック。</p>
<h2 id="u30C8_u30EC_u30FC_u30B9_u30ED_u30B0_u3092_u57CB_u3081_u8FBC_u3080"><a href="#u30C8_u30EC_u30FC_u30B9_u30ED_u30B0_u3092_u57CB_u3081_u8FBC_u3080" class="headerlink" title="トレースログを埋め込む"></a>トレースログを埋め込む</h2><p>UI 実装は、ユーザ操作とのインタラクションによってコールされる関数の順序性などを確認しながら行いたいもの。それにパフォーマンスも気になる。そこで、<code>console.log</code> ではなく <a href="https://github.com/visionmedia/debug" target="_blank" rel="external">debug</a> を使って各関数の頭にトレースログを埋め込むというのをオススメ。簡易なパフォーマンス計測やトレースログのフィルタやログの色分けなどができて便利。</p>
<p>そしてリリースビルドには debug をバンドルしたくないので、<a href="https://github.com/keik/undebuggify" target="_blank" rel="external">undebuggify</a> で debug 関連コードを除去するトランスフォームをすると具合がいい。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.keik.info/2016/02/22/release-ac-box/" data-id="cil6d5z1l000jj5gzgitm4gb2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ac-box/">ac-box</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/autocomplete/">autocomplete</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/combobox/">combobox</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flux/">flux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-release-undebuggify" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/18/release-undebuggify/" class="article-date">
  <time datetime="2016-02-18T14:18:57.000Z" itemprop="datePublished">2016-02-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/18/release-undebuggify/">undebuggify リリースした</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/visionmedia/debug" target="_blank" rel="external">debug</a> を使用しているコードを AST を辿って削除する Browserify Transform モジュール <a href="https://github.com/keik/undebuggify" target="_blank" rel="external">undebuggify</a> を作ったのでご活用ください。使用例は README.md に書いてあります。</p>
<h2 id="debug__u3063_u3066_u4F55"><a href="#debug__u3063_u3066_u4F55" class="headerlink" title="debug って何"></a>debug って何</h2><p>ロガー。個人的に JavaScript でトレースログを埋め込む際は <code>console.log</code> ではなく debug を常用している。なぜなら</p>
<ul>
<li>ログを埋め込んだモジュールごとに異なる色で出力される</li>
<li>前回ログ出力からの経過時間などが出力される</li>
<li>環境変数をいじることで出力したいログを絞り込むことができる</li>
</ul>
<p>など便利な機能があるから。</p>
<h2 id="u306A_u305C_debug__u3092_u524A_u9664_u3059_u308B_u5FC5_u8981_u304C_u3042_u308B_u306E_u304B"><a href="#u306A_u305C_debug__u3092_u524A_u9664_u3059_u308B_u5FC5_u8981_u304C_u3042_u308B_u306E_u304B" class="headerlink" title="なぜ debug を削除する必要があるのか"></a>なぜ debug を削除する必要があるのか</h2><p>ウェブブラウザ向けスクリプトをリリースする際、ログ出力コードは削除しておきたい。第一にダサいし、また debug の 4KB のコードをバンドルしたくないから。</p>
<h2 id="debug__u3058_u3083_u306A_u304F_u3066_console-log__u4F7F_u3063_u3066_u3044_u308B_u3093_u3060_u3051_u3069"><a href="#debug__u3058_u3083_u306A_u304F_u3066_console-log__u4F7F_u3063_u3066_u3044_u308B_u3093_u3060_u3051_u3069" class="headerlink" title="debug じゃなくて console.log 使っているんだけど"></a>debug じゃなくて console.log 使っているんだけど</h2><p><a href="https://github.com/alanshaw/stripify" target="_blank" rel="external">stripify</a> をご活用ください。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.keik.info/2016/02/18/release-undebuggify/" data-id="cil6d5z22000tj5gzti1f5sir" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ast/">ast</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/browserify/">browserify</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/transform/">transform</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-frontend" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/16/frontend/" class="article-date">
  <time datetime="2016-02-16T12:00:00.000Z" itemprop="datePublished">2016-02-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/16/frontend/">Grunt や gulp のかわりに Make も使ってみよう</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>フロントエンド開発のタスクランナーとして Grunt や gulp、npm run-script なんかを使ってきたが、今は Make を使っている。フロントエンド分野ではあまり馴染みのないツールかもしれないが、必要十分な機能性と高い表現力のバランスの良さを実感し、一巡辿ってゴールにたどり着いた感がある。もっと流行ってほしい。</p>
<p>Make は Makefile に定義したルールにしたがってビルドプロセスを実行する。しかし Makefile には独特な表現が多く、<code>$@</code> とかのマクロはググりようがなくてちょっとしんどい。とはいえ、いきなり高度な使い方をしようと思わなければ簡単なので、以下を参考に導入してみてほしい。</p>
<h2 id="STEP_1-__u30B3_u30DE_u30F3_u30C9_u306E_u30A8_u30A4_u30EA_u30A2_u30B9_u3092_u66F8_u304F"><a href="#STEP_1-__u30B3_u30DE_u30F3_u30C9_u306E_u30A8_u30A4_u30EA_u30A2_u30B9_u3092_u66F8_u304F" class="headerlink" title="STEP 1. コマンドのエイリアスを書く"></a>STEP 1. コマンドのエイリアスを書く</h2><p>基本はただのエイリアスです。</p>
<h3 id="JavaScript__u3092_u30D3_u30EB_u30C9_u3059_u308B_u4F8B"><a href="#JavaScript__u3092_u30D3_u30EB_u30C9_u3059_u308B_u4F8B" class="headerlink" title="JavaScript をビルドする例"></a>JavaScript をビルドする例</h3><p>次の Makefile があるディレクトリで <code>make build</code> コマンドを実行すれば <a href="https://github.com/substack/browserify-website" target="_blank" rel="external">Browserify</a> でのビルドが実行される。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">build:</span></span><br><span class="line">	node_modules/.bin/browserify src/main.js -o dist/bundle.js</span><br></pre></td></tr></table></figure>
<p>なお <code>build</code> というタスク名的な部分のことを <strong>ターゲット</strong> という。</p>
<p>ミニファイしたければ <a href="https://github.com/mishoo/UglifyJS2" target="_blank" rel="external">Uglify</a> にパイプ、もしくは <a href="https://github.com/hughsk/uglifyify" target="_blank" rel="external">uglifyify</a> トランスフォームすればいい。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">build:</span></span><br><span class="line">	node_modules/.bin/browserify src/main.js | \</span><br><span class="line">	node_modules/.bin/uglifyjs -o dist/bundle.js</span><br></pre></td></tr></table></figure>
<p>ターゲットの部分には生成したいファイル名、例えば dist/bundle.js などを指定できる。そうした場合の Makefile は以下のように、コマンドは <code>make dist/bundle.js</code> となり、自然言語的に理解しやすくなる。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dist/bundle.js:</span><br><span class="line">	@node_modules/.bin/browserify src/main.js | \</span><br><span class="line">	node_modules/.bin/uglifyjs -o dist/bundle.js</span><br></pre></td></tr></table></figure>
<p>なおコマンド部のはじめに <code>@</code> をつけてみたが、これは実行するコマンドを標準出力しないための記号。コマンドを確認したければつけないままで OK。</p>
<h3 id="JavaScript__u3092_u30A4_u30F3_u30AF_u30EA_u30E1_u30F3_u30BF_u30EB_u30D3_u30EB_u30C9_u3059_u308B_u4F8B"><a href="#JavaScript__u3092_u30A4_u30F3_u30AF_u30EA_u30E1_u30F3_u30BF_u30EB_u30D3_u30EB_u30C9_u3059_u308B_u4F8B" class="headerlink" title="JavaScript をインクリメンタルビルドする例"></a>JavaScript をインクリメンタルビルドする例</h3><p><a href="https://github.com/substack/watchify" target="_blank" rel="external">watchify</a> がそれ自身でインクリメンタルビルドする機能を持っているので、これを叩くだけ。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watch-js:</span><br><span class="line">	@node_modules/.bin/watchify src/main.js -o src/bundle.js -v -d</span><br></pre></td></tr></table></figure>
<h2 id="STEP_2-__u4F9D_u5B58_u30BF_u30FC_u30B2_u30C3_u30C8_u3092_u66F8_u304F"><a href="#STEP_2-__u4F9D_u5B58_u30BF_u30FC_u30B2_u30C3_u30C8_u3092_u66F8_u304F" class="headerlink" title="STEP 2. 依存ターゲットを書く"></a>STEP 2. 依存ターゲットを書く</h2><p>上の Makefile は本当にただのエイリアスに過ぎないので、次は <strong>依存ターゲット</strong> を導入する。</p>
<p>dist/bundle.js を生成するまでに必要な依存関係をリスト化してみると、</p>
<ul>
<li><strong>dist/bundle.js は</strong><ul>
<li><code>browserify</code> や <code>uglifyjs</code> コマンドが使用できなければ出力できない。つまり Browserify や Uglify などの Node モジュールが格納されている <em>node_modules ディレクトリの存在に依存</em> している。</li>
<li>dist/bundle.js は、 dist ディレクトリがないと出力できない。つまり <em>dist ディレクトリの存在に依存</em> している。</li>
</ul>
</li>
<li><strong>node_modules は</strong><ul>
<li>package.json ファイルを元に <code>npm install</code> コマンドによって作られる。つまり <em>package.json ファイルの存在</em> に依存している。</li>
</ul>
</li>
</ul>
<p>これらの依存関係の解決方法を Makefile で表現すると次のようになる。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dist/bundle.js: node_modules dist</span><br><span class="line">	@node_modules/.bin/browserify src/main.js | \</span><br><span class="line">	node_modules/.bin/uglifyjs -o dist/bundle.js</span><br><span class="line"></span><br><span class="line"><span class="title">dist:</span></span><br><span class="line">	@mkdir -p dist</span><br><span class="line"></span><br><span class="line">node_modules: package.json</span><br><span class="line">	@npm install</span><br></pre></td></tr></table></figure>
<p>このとき <code>make dist/bundle.js</code> を実行すると、必要な依存を自動的に解決してくれる。つまり、初めに node_modules の解決のため <code>npm install</code> が実行され、次に dist の解決のため <code>mkdir -p dist</code> が実行される。最後に dist/bundle.js が生成される。つまり <code>make dist/bundle.js</code> コマンド一つを実行すれば、他のコマンドを覚えたり実行せずにビルドできる。</p>
<p>しかもターゲットと依存ターゲットのファイルのタイムスタンプを比較し、更新が必要なければコマンドはスキップされる。例えば package.json よりも node_modules が新しければ、node_modules の更新は不要なので <code>npm install</code> は実行されない。</p>
<h2 id="STEP_3-__u4ED6_u306E_u7D99_u7D9A_u30D7_u30ED_u30BB_u30B9_u3092_u4E26_u5217_u5B9F_u884C_u3059_u308B"><a href="#STEP_3-__u4ED6_u306E_u7D99_u7D9A_u30D7_u30ED_u30BB_u30B9_u3092_u4E26_u5217_u5B9F_u884C_u3059_u308B" class="headerlink" title="STEP 3. 他の継続プロセスを並列実行する"></a>STEP 3. 他の継続プロセスを並列実行する</h2><p>ウェブサーバ越しに動作・表示確認するために <a href="https://github.com/indexzero/http-server" target="_blank" rel="external">http-server</a> を起動したいとする。さらに RESTful API モックサーバ <a href="https://github.com/typicode/json-server" target="_blank" rel="external">json-server</a> を起動したいとする。とりあえずそれぞれのプロセスの起動のためのターゲットを定義すると以下のようになる。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">run-dev-server: node_modules</span><br><span class="line">	@node_modules/.bin/http-server</span><br><span class="line"></span><br><span class="line">run-api-mock-server: node_modules</span><br><span class="line">	@node_modules/.bin/json-server --watch db.json</span><br><span class="line"></span><br><span class="line">watch-js:</span><br><span class="line">	@node_modules/.bin/watchify src/main.js -o src/bundle.js -v -d</span><br></pre></td></tr></table></figure>
<p>これらのプロセスは並列に実行したいもの。そんな時は Make の <code>j</code> オプションでパラレル実行できるので、<code>make -j run-dev-server run-api-mock-server watch-js</code> のようなコマンドを実行するといい。とはいえこのコマンドを毎回叩くのは面倒なので、これを更に Makefile に定義しておく。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">watch:</span></span><br><span class="line">	@make -j run-dev-server run-api-mock-server watch-js</span><br></pre></td></tr></table></figure>
<p>こうすれば、<code>make watch</code> すれば、3つのプロセスがパラレル実行される。仮にエラーでどれかのタスクが停止しても、Make のプロセスを止めればすべてのプロセスが止まるので、バックグラウンドでプロセスが残り続ける心配もない。npm run-script などで <code>&amp;</code> 区切りで実行すると、バックグラウンドプロセスが残りやすいので、これは便利。</p>
<h2 id="STEP_4-__u5909_u6570_u3068_u304B_u30DE_u30AF_u30ED_u3068_u304B_u95A2_u6570_u3068_u304B_u4F7F_u3046"><a href="#STEP_4-__u5909_u6570_u3068_u304B_u30DE_u30AF_u30ED_u3068_u304B_u95A2_u6570_u3068_u304B_u4F7F_u3046" class="headerlink" title="STEP 4. 変数とかマクロとか関数とか使う"></a>STEP 4. 変数とかマクロとか関数とか使う</h2><p>ここまでの内容で十分に便利に使えるが、Makefile らしさを出すために以降では簡単なマクロを使う例を紹介する。ただししんどくなってきたら本末転倒なのでやめよう。</p>
<p>はじめのほうに書いた次の Makefile は、</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dist/bundle.js:</span><br><span class="line">	@node_modules/.bin/browserify src/main.js | \</span><br><span class="line">	node_modules/.bin/uglifyjs -o dist/bundle.js</span><br></pre></td></tr></table></figure>
<p>次の様に書き換えることができる。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">SRC</span>       = src</span><br><span class="line"><span class="constant">DIST</span>      = dist</span><br><span class="line"><span class="constant">MAIN_JS</span>   = <span class="variable">$(SRC)</span>/main.js</span><br><span class="line"><span class="constant">BUNDLE_JS</span> = <span class="variable">$(DIST)</span>/bundle.js</span><br><span class="line"></span><br><span class="line">$(BUNDLE_JS):</span><br><span class="line">	@node_modules/.bin/browserify <span class="variable">$(MAIN_JS)</span> | \</span><br><span class="line">	node_modules/.bin/uglifyjs -o $@</span><br></pre></td></tr></table></figure>
<p>変数定義 <code>VAR=foo</code> と参照 <code>$(VAR)</code>、更にターゲット名を表すマクロ <code>$@</code> を導入した。</p>
<h2 id="28_u756A_u5916_29_STEP_5-_Windows__u5BFE_u5FDC"><a href="#28_u756A_u5916_29_STEP_5-_Windows__u5BFE_u5FDC" class="headerlink" title="(番外) STEP 5. Windows 対応"></a>(番外) STEP 5. Windows 対応</h2><p>Windows よくわからないけど、MinGW とか使ってほしい。コマンドプロンプトでは諦めてほしい。こんな感じで <code>/</code> を <code>\</code> に置換する関数を使うといけたりもする。<strong>諦めてほしい</strong>。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ifdef SystemRoot</span><br><span class="line">	fixPath = <span class="variable">$(subst /,\,$1)</span></span><br><span class="line">else</span><br><span class="line">	fixPath = $1</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">$(call fixPath,dist/bundle.js):</span><br><span class="line">	@<span class="variable">$(call fixPath,node_modules/.bin/browserify src/main.js -o dist/bundle.js)</span></span><br></pre></td></tr></table></figure>
<h2 id="Grunt_2C_gulp_2C_npm_run-script__u3068_u306E_u6BD4_u8F03"><a href="#Grunt_2C_gulp_2C_npm_run-script__u3068_u306E_u6BD4_u8F03" class="headerlink" title="Grunt, gulp, npm run-script との比較"></a>Grunt, gulp, npm run-script との比較</h2><ul>
<li>Grunt 遅い、タスク定義が面倒。</li>
<li>gulp 早いけどタスク定義が面倒。</li>
<li>Grunt も gulp も、プラグイン化が必要。バージョンアップ追従のタイムラグや、中にはメンテナンスされなくなるものもあるので、プラグイン化されたものではなく生で使えるに越したことはない。</li>
<li>npm run-script は表現力が足りない。簡単なタスクならいいが、マルチラインやコメントが書けないので複雑なタスクは無理。</li>
<li>シェルスクリプトもいいけど、一貫したプラクティスを提供する Make のほうが乗っかりやすい。</li>
</ul>
<h2 id="u30B5_u30F3_u30D7_u30EB"><a href="#u30B5_u30F3_u30D7_u30EB" class="headerlink" title="サンプル"></a>サンプル</h2><p><a href="https://github.com/keik/frontend-with-make" target="_blank" rel="external">https://github.com/keik/frontend-with-make</a></p>
<p><code>git clone https://github.com/keik/frontend-with-make.git</code> して <code>make</code> すれば依存パッケージのインストールやら何やらができるはず。Makefile 活用例のサンプルなので、アプリ部分のショボさは無視してください。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.keik.info/2016/02/16/frontend/" data-id="cil6d5z290010j5gzqk99b48a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/make/">make</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/task-runner/">task-runner</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-slickgrid-colgroup-plugin" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/17/slickgrid-colgroup-plugin/" class="article-date">
  <time datetime="2015-12-17T13:11:00.000Z" itemprop="datePublished">2015-12-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/17/slickgrid-colgroup-plugin/">slickgrid-colgroup-plugin 作った</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/mleibman/SlickGrid" target="_blank" rel="external">SlickGrid</a> のヘッダをグループ化するプラグイン <a href="https://github.com/keik/slickgrid-colgroup-plugin" target="_blank" rel="external">slickgrid-colgroup-plugin</a> を作ったので、ギョームシステムの開発とかにどうぞ。MIT。</p>
<p><a href="http://keik.github.io/slickgrid-colgroup-plugin/examples/" target="_blank" rel="external">デモページ</a> にいくつかのサンプルを置いてます。</p>
<p>SlickGrid 自体についても簡単に紹介すると、大量のデータをグリッドで表示できることを特徴としたフレームワークで、その仕組としてはスクロールされるたびに表示領域の DOM 要素だけを動的に作り直すことによって大量データを少ない DOM 要素数で表現している。</p>
<p>プラグイン v1.0.4 における使い方は、SlickGrid オブジェクトにプラグインを登録して</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid.registerPlugin(<span class="keyword">new</span> Slick.Plugins.ColGroup());</span><br></pre></td></tr></table></figure>
<p>カラム定義で <code>children</code> プロパティを用いてグループ構造を持ったカラム定義を与えるだけ。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> columns = [</span><br><span class="line">  &#123;id: <span class="string">'col1'</span>, name: <span class="string">'col 1'</span>, children: [</span><br><span class="line">    &#123;id: <span class="string">'col1-1'</span>, name: <span class="string">'col 1-1'</span>, field: <span class="string">'col1-1'</span>&#125;,</span><br><span class="line">    &#123;id: <span class="string">'col1-2'</span>, name: <span class="string">'col 1-2'</span>, field: <span class="string">'col1-2'</span>&#125;</span><br><span class="line">  ]&#125;,</span><br><span class="line">  &#123;id: <span class="string">'col2'</span>, name: <span class="string">'col 2'</span>, children: [</span><br><span class="line">    &#123;id: <span class="string">'col2-1'</span>, name: <span class="string">'col 2-1'</span>, field: <span class="string">'col2-1'</span>&#125;,</span><br><span class="line">    &#123;id: <span class="string">'col2-2'</span>, name: <span class="string">'col 2-2'</span>, children: [</span><br><span class="line">      &#123;id: <span class="string">'col2-2-1'</span>, name: <span class="string">'col 2-2-1'</span>, field: <span class="string">'col2-2-1'</span>&#125;,</span><br><span class="line">      &#123;id: <span class="string">'col2-2-2'</span>, name: <span class="string">'col 2-2-2'</span>, field: <span class="string">'col2-2-2'</span>&#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">  ]&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.keik.info/2015/12/17/slickgrid-colgroup-plugin/" data-id="cil6d5z0l0000j5gz9h4rub0d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/slickgrid/">slickgrid</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ac-box/">ac-box</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ast/">ast</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/autocomplete/">autocomplete</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/browserify/">browserify</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/combobox/">combobox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flux/">flux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/less/">less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/make/">make</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/slickgrid/">slickgrid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/task-runner/">task-runner</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/transform/">transform</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ac-box/" style="font-size: 10px;">ac-box</a> <a href="/tags/ast/" style="font-size: 10px;">ast</a> <a href="/tags/autocomplete/" style="font-size: 10px;">autocomplete</a> <a href="/tags/browserify/" style="font-size: 15px;">browserify</a> <a href="/tags/combobox/" style="font-size: 10px;">combobox</a> <a href="/tags/flux/" style="font-size: 10px;">flux</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/less/" style="font-size: 10px;">less</a> <a href="/tags/make/" style="font-size: 15px;">make</a> <a href="/tags/slickgrid/" style="font-size: 10px;">slickgrid</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/task-runner/" style="font-size: 15px;">task-runner</a> <a href="/tags/transform/" style="font-size: 10px;">transform</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">2月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">12月 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/02/28/java-with-frontend/">Java とフロントエンドの付き合い方、それとチュートリアル</a>
          </li>
        
          <li>
            <a href="/2016/02/22/release-ac-box/">オートコンプリートライブラリを作った話と UI 実装のテクニックについて</a>
          </li>
        
          <li>
            <a href="/2016/02/18/release-undebuggify/">undebuggify リリースした</a>
          </li>
        
          <li>
            <a href="/2016/02/16/frontend/">Grunt や gulp のかわりに Make も使ってみよう</a>
          </li>
        
          <li>
            <a href="/2015/12/17/slickgrid-colgroup-plugin/">slickgrid-colgroup-plugin 作った</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 keik<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-68538794-2', 'auto');ga('send', 'pageview');
</script>

<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>